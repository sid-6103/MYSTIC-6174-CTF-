<html>

<head>
    <title>level 1 ans </title>
</head>

<body>
    <br><br><br>

    There are dozens of articles headed ‘The 7 Sins of Programming’in the internet, but here’s the thing – most of them
    are simply a list of bad practices. They have little or nothing to do with the actual 7 sins of the Bible, and no
    reason in the world why they should be precisely 7. You'll now read them below, hoping that it leads you the first
    hint you will require in order to achieve your main flag by the end of, let's say... your next 32 mintues
    approximately??

    Let us go ahead, then, and cast the first stone! Our list of sins begins with….

    ENVY
    Envy is probably not going to be a big problem for you if you’re working for a large company, in which you are
    assigned set tasks and paid a fixed salary. But it can spell trouble for those who wish to go solo and enter the
    world of tech as entrepreneurs.

    While entrepreneurs of all stripes will of course benefit enormously from learning how to code, there exists a
    particular culture surrounding the mythological “tech start-up” which is not always healthy (and which is certainly
    not the same as that of a regular small business). Because there are so many stories of new startups becoming
    unicorns overnight and turning their founders into billionaires, newcomers often aim straight for that model,
    instead of building their business in the way that would best suit their product (which sometimes means slowly,
    gently, and patiently).

    These people are often saddled with fantasies about creating ‘the next Airbnb’ or ‘the next Uber’, and as a
    consequence they put ambitious imitation before intelligent business decisions (never mind genuine innovation). By
    far the worst cases are those of people who attempt to copy not just business models but entire ideas, creating for
    example a dating app that has a few original features but is fundamentally just another version of Tinder.

    At the heart of every successful startup there is an original idea. Don’t look at what others have accomplished and
    think that you want to have that too. Create your own things, and build them in the only way that will make them any
    good – your way.

    GREED
    The people in tech who most urgently need a wake up call about their greed are probably not the sort who will read
    this blog – namely, that super-wealthy micro-minority who infamously exploit workers and dodge taxes.

    But it would not be true to say that more ordinary people cannot fall victims to greed.

    Indeed, for the average developer greed manifests itself as forgetting the human. Not everything that tech brings to
    the life of people is good, and not all of it makes society better. I’m not just talking about the most obvious
    examples, like software that makes military drones better at killing. There is an entire realm of tech that is
    dedicated to addictively grabbing and keeping people’s attention. Because of it, social media platforms can become
    anxiety-inducing time drains, while news sites are turned into populist echo chambers.

    All of this is enabled because, sadly, many in the tech industry only think of the work they do in terms of the
    returns it brings to them personally, and neglect to consider its broader ethical dimension.

    True, occasionally times are tough and you’ll need to take whatever job you can get. But you still have a
    responsibility to ask yourself if the job you’re doing is going to actively exacerbate the problems of others.
    Putting your personal profit above that of your community as a whole is the very definition of greed, and when
    enough people start thinking that way, the result is that Planet Tech turns and shows its darkest side.

    SLOTH
    There are myriad ways one can be lazy when writing code, and it would have been only too easy to pick any passive
    bad habit and hold it up as the pre-eminent example of the sin (e.g. “people who don’t bother to properly comment
    their code are clearly being slothful!”).

    But this would not really make for the best case study. Instead, the true negative consequences of sloth for a
    developer do not come in the form of poorly written code, but in that of career stagnation.

    The industry of tech is characterized by constant innovation, with new technologies and programming languages
    falling in and out of favour all the time. The modern professional programmer is therefore a figure who never stops
    learning and updating their skills, whether through their work or outside of it. Job-hopping is relatively common
    among developers for a variety of reasons, but one of them is the fact that developers who,
    , reach a point in their job where they are no longer learning anything new have a
    strong incentive to move on.

    Somebody who does not do this, and prefers to rest in the comfort of the skills they already have, will see their
    employability and their salary ceiling slowly (and sometimes not so slowly) being eroded. If their specialism is in
    a technology that has become obsolete, their experience may ironically work against them rather than for them. All
    the while, sloth will whisper in their ears not to bother, and to stay nice and put. Remember that there is nothing,
    but truly nothing, that sloth hates more in a programmer than seeing them learn new things.

    PRIDE
    Pride, the original sin, is ubiquitous among tech professionals. Being proficient with technologies which the vast
    majority of the population doesn’t understand can lead even the most naturally modest of individuals to grow a bit
    of a smug attitude.

    Perhaps surprisingly, the negative consequences of pride are less about the effects it can have on teamwork and
    workplace atmosphere than they are about the quality of the work itself. Boastful and condescending people will
    become unpopular, sure, but they can usually get away with a bit of a bad attitude if they do deliver consistent
    success, excellence, and outstanding quality.

    The trouble with pride, however, is that it sows the seeds of its own ruin.

    Developers who are too proud of themselves will make a number of mistakes, some of them as basic as failing to run
    unit tests out of the misguided belief that when it comes to their work, these are simply not necessary.

    The solutions they come up with may be unnecessarily convoluted or complex or difficult to maintain. Their frame of
    mind – the very thing which originally made them so proud – will slowly grow rigid over time, so that they will rely
    increasingly on the same technologies and tools, believing the proof that these are excellent lies in the fact that
    they use them (and not the other way around).

    There is, unfortunately, not much that can be said to help these people – pride notoriously shuts down feedback
    coming from the outside. The only cure is for people to suffer the consequences of their pride, and see with their
    own eyes how their efficiency, their creativity, and their productivity have all been reduced. If they’re not too
    proud even for that, anyway.

    LUST
    Lust is not commonly associated to programming and the IT world, but the reasons for this disconnect are the same
    reasons why it’s actually worth talking about about it. True, sexual desire is unlikely to affect your ability to
    write code, whichever way you choose to live it. But it can have tangible effects on the atmosphere, cohesion, and
    functionality of the team you’re in.

    The world of software development is unfortunately still very much a man’s world, with the latest survey on Stack
    Overflow suggesting that men made up a whopping 91.67% of professional developers in 2021. Why this is happening –
    and why this absolutely is a problem – is a much broader topic than this blog can hope to address, but we can
    highlight one very relevant fact: when men are in the company only of other men, they will engage in behavior they
    normally wouldn’t adopt in mixed groups (or, in more technical terms, gender-segregated communities develop
    behavioral differences – and of course this principle holds true for women as well).

    The most obvious and common example of this is how men talk to each other about sex. Thus, jokes that are especially
    crude and offensive are usually just an effect of our powerful sex drives looking for an outlet – aka, our lust.

    If you are among that 91.67% of male programmers, I would encourage you to consider how a woman may feel when
    entering an environment where the standard mode of interaction is man-on-man communication. Sure, perhaps making a
    quip about boobs with the guys may feel natural (or even welcoming) to you, but to that lone woman in the room who
    overhears you, it’s much more likely to make her uncomfortable.

    We’re not trying to say that you shouldn’t joke or laugh in the office, of course, only that you put yourself in
    someone else’s shoes when doing so. And if you really want to be a good person to them, then put your lust in check.
    At least on the workplace.

    WRATH
    Getting angry while coding is a very common experience. Coding can definitely get very frustrating, and, to
    paraphrase Yoda for a moment, tx24_ctf{gr3p_15_@w3s0m3_2116b979}  frustration leads to anger.

    Unlike pride, however, wrath is unlikely to damage your productivity. Sure, it may occasionally lower your focus,
    which means finding that one bug that is dancing Salsa on your nerves may take a little bit longer, but that’s about
    as far as it goes. The temptation to throw your computer out of the window will – I sincerely hope – remain a mere
    temptation.

    Where you do have to be wary of wrath as a programmer is when dealing with non-tech people, be they colleagues or
    clients, or else with junior developers. If you’re working as a freelance web developer and halfway through your
    project your client asks that you reinvent Google Maps and integrate it into their website within 3 days, the
    correct response is not to tell them that that’s the stupidest thing you’ve ever heard and that they should read an
    article about how software development works for once in their lives. That may be true, but it’s still not what you
    should be saying.

    Angry people usually have a lot of trouble seeing things from the perspective of those they’re angry with. When you
    work every day with technologies that, as we mentioned above, are outside most people’s sphere of knowledge, you
    tend to lose touch. Thus, when someone you’re working with does or says something that, from your perspective, seems
    incredibly stupid, that’s the time to take a deep breath and correct their mistake politely and with a smile.

    Letting your anger get the better of you is only going to isolate you within your team, put you on the bad side of
    management, and make sure that clients will not call you back. Remember, tech is not pop culture, it’s a field of
    expertise – don’t get angry at people for not sharing yours.

    GLUTTONY
    … Actually nothing. There is no way of discussing the sin of gluttony in a way that is both relevant to programming
    and also true to the topic, not without a massive exercise in clutching at straws.

    Go ahead and eat what you like. It’s not going to make you a worse programmer, I promise. Call it one of the perks
    of the job.

    Let's hope it concludes our topic for the day and we helped you find your flag for your first level.

    Wait!!! You didn't find the flag yet??!! No worries read it again if you have time :)

    In 1949 the mathematician D. R. Kaprekar from Devlali, India, devised a process now known as Kaprekar's operation.
    First choose a four digit number where the digits are not all the same (that is not 1111, 2222,...). Then rearrange
    the digits to get the largest and smallest numbers these digits can make. Finally, subtract the smallest number from
    the largest to get a new number, and carry on repeating the operation for each new number.

    It is a simple operation, but Kaprekar discovered it led to a surprising result. Let's try it out, starting with the
    number 2005, the digits of last year. The maximum number we can make with these digits is 5200, and the minimum is
    0025 or 25 (if one or more of the digits is zero, embed these in the left hand side of the minimum number). The
    subtractions are:

    5200 - 0025 = 5175
    7551 - 1557 = 5994
    9954 - 4599 = 5355
    5553 - 3555 = 1998
    9981 - 1899 = 8082
    8820 - 0288 = 8532
    8532 - 2358 = 6174
    7641 - 1467 = 6174

    When we reach 6174 the operation repeats itself, returning 6174 every time. We call the number 6174 a kernel of this
    operation. So 6174 is a kernel for Kaprekar's operation, but is this as special as 6174 gets? Well not only is 6174
    the only kernel for the operation, it also has one more surprise up its sleeve. Let's try again starting with a
    different number, say 1789.

    9871 - 1789 = 8082
    8820 - 0288 = 8532
    8532 - 2358 = 6174

    We reached 6174 again!

    The digits of any four digit number can be arranged into a maximum number by putting the digits in descending order,
    and a minimum number by putting them in ascending order. So for four digits a,b,c,d where

    9 ≥ a ≥ b ≥ c ≥ d ≥ 0

    and a, b, c, d are not all the same digit, the maximum number is abcd and the minimum is dcba.

    We can calculate the result of Kaprekar's operation using the standard method of subtraction applied to each column
    of this problem:

    a b c d
    - d c b a
    A B C D
    which gives the relations

    D = 10 + d - a (as a > d)
    C = 10 + c - 1 - b = 9 + c - b (as b > c - 1)
    B = b - 1 - c (as b > c)
    A = a - d
    for those numbers where a>b>c>d.

    A number will be repeated under Kaprekar's operation if the resulting number ABCD can be written using the initial
    four digits a,b,c and d. So we can find the kernels of Kaprekar's operation by considering all the possible
    combinations of {a, b, c, d} and checking if they satisfy the relations above. Each of the 4! = 24 combinations
    gives a system of four simultaneous equations with four unknowns, so we should be able to solve this system for a,
    b, c and d.

    It turns out that only one of these combinations has integer solutions that satisfy 9 ≥ a ≥ b ≥ c ≥ d ≥ 0. That
    combination is ABCD = bdac, and the solution to the simultaneous equations is a=7, b=6, c=4 and d=1. That is ABCD =
    6174. There are no valid solutions to the simultaneous equations resulting from some of the digits in {a,b,c,d}
    being equal. Therefore the number 6174 is the only number unchanged by Kaprekar's operation — our mysterious number
    is unique.

    For three digit numbers the same phenomenon occurs. For example applying Kaprekar's operation to the three digit
    number 753 gives the following:

    753 - 357 = 396
    963 - 369 = 594
    954 - 459 = 495
    954 - 459 = 495

    The number 495 is the unique kernel for the operation on three digit numbers, and all three digit numbers reach 495
    using the operation. Why don't you check it yourself?

    How fast to 6174?
    It was about 1975 when I first heard about the number 6174 from a friend, and I was very impressed at the time. I
    thought that it would be easy to prove why this phenomenon occurred but I could not actually find the reason why. I
    used a computer to check whether all four digit numbers reached the kernel 6174 in a limited number of steps. The
    program, which was about 50 statements in Visual Basic, checked all of 8991 four digit numbers from 1000 to 9999
    where the digits were not all the same.

    The table below shows the results: every four digit number where the digits aren't all equal reaches 6174 under
    Kaprekar's process, and in at most seven steps. If you do not reach 6174 after using Kaprekar's operation seven
    times, then you have made a mistake in your calculations and should try it again!

    Iteration Frequency
    0 1
    1 356
    2 519
    3 2124
    4 1124
    5 1379
    6 1508
    7 1980
    Which way to 6174?
    My computer program checked all 8991 numbers, but in his article Malcolm Lines explains that it is enough to check
    only 30 of all the possible four digit numbers when investigating Kaprekar's operation.

    As before let's suppose that the four digit number is abcd, where

    9 ≥ a ≥ b ≥ c ≥ d ≥ 0.

    Let us calculate the first subtraction in the process. The maximum number is 1000a+100b+10c+d and the minimum number
    is 1000d+100c+10b+a. So the subtraction is:

    1000a + 100b + 10c + d - (1000d + 100c + 10b + a)
    = 1000(a-d) + 100(b-c) + 10(c-b) + (d-a)
    = 999(a-d) + 90(b-c)

    The possible value of (a-d) is from 1 to 9, and (b-c) is from 0 to 9. By running through all the possibilities, we
    can see all the possible results from the first subtraction in the process.

    We have seen that four and three digit numbers reach a unique kernel, but how about other numbers? It turns out that
    the answers for those is not quite as impressive. Let try it out for a two digit number, say 28:

    82 - 28 = 54
    54 - 45 = 9
    90 - 09 = 81
    81 - 18 = 63
    63 - 36 = 27
    72 - 27 = 45
    54 - 45 = 9

    It doesn't take long to check that all two digit numbers will reach the loop 9→81→63→27→45→9. Unlike for three and
    four digit numbers, there is no unique kernel for two digit numbers.

    But what about five digits? Is there a kernel for five digit numbers like 6174 and 495? To answer this we would need
    to use a similar process as before: check the 120 combinations of {a,b,c,d,e} for ABCDE such that

    9 ≥ a ≥ b ≥ c ≥ d ≥ e ≥ 0

    and

    abcde - edcba = ABCDE.

    Thankfully the calculations have already been done by a computer, and it is known that there is no kernel for
    Kaprekar's operation on five digit numbers. But all five digit numbers do reach one of the following three loops:

    71973→83952→74943→62964→71973
    75933→63954→61974→82962→75933
    59994→53955→59994

    As Malcolm Lines points out in his article, it will take a lot of time to check what happens for six or more digits,
    and this work becomes extremely dull! To save you from this fate, the following table shows the kernels for two
    digit to ten digit numbers (for more see Mathews Archive of Recreational Mathematics). It appears that Kaprekar's
    operation takes every number to a unique kernel only for three and four digit numbers.
</body>

</html>